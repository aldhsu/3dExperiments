<!doctype html>
<html lang="en">
  <head>
      <title>Perlin noise | Fireball explosion</title>
      <meta charset="utf-8">
      <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
      <link rel="stylesheet" href="assets/style.css">
  </head>

  <body>
  <h1>Webjam-01</h1>
  <p class="play">Play</p>
  <p class="stop">Stop</p>
      <div id="container"></div>
  </body>
  <script src="js/audio.js"></script>

  <script src="js/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/underscore-min.js"></script>
  <script type="x-shader/x-vertex" id="vertexShader">
    uniform float amplitude;
    attribute float displacement;
    varying vec3 vNormal;

    void main() {

      vNormal = normal;

      // multiply our displacement by
      // the amplitude. The amp will
      // get animated so we'll have
      // animated displacement
      vec3 newPosition =
        position + normal *
        vec3(displacement);

      gl_Position = projectionMatrix *
                    modelViewMatrix *
                    vec4(newPosition, 1.0);
    }
  </script>

  <script type="x-shader/x-vertex" id="fragmentShader">
    // same name and type as VS
    varying vec3 vNormal;
    uniform float red, green, blue;
    void main() {

      // calc the dot product and clamp
      // 0 -> 1 rather than -1 -> 1
      vec2 position;
      vec3 light = vec3(0.5, 0.2, 1.0);

      // ensure it's normalized
      light = normalize(light);

      // calculate the dot product of
      // the light to the vertex normal
      float dProd =
                        dot(vNormal, light);

      // feed into our frag colour
      gl_FragColor = vec4(red - dProd, // R
                          green - dProd, // G
                          blue - dProd, // B
                          1.0);  // A

    }
  </script>

  <script type="text/javascript" id="mainCode">
  // Put the main code
  var container,
  material,
  renderer,
  scene,
  camera,
  mesh,
  fov = 30,
  // create attributes for vertex shader
  attributes = {
    displacement: {
      type: 'f',
      value: []
    }
  },
  uniforms = {
    red: {
      type: 'f', // a float
      value: 0
    },
    green: {
      type: 'f', // a float
      value: 0
    },
    blue: {
      type: 'f', // a float
      value: 0
    }
  }

  $(window).ready(function() {

    // grab the container from the DOM
    container = $("#container")[0];

    // create a scene
    scene = new THREE.Scene();

    // create a camera the size of the browser window
    // and place it 100 units away, looking towards the center of the scene
    camera = new THREE.PerspectiveCamera(
        fov,
        window.innerWidth / window.innerHeight,
        1,
        10000 );
    camera.position.z = 1000;
    camera.target = new THREE.Vector3( 0, 0, 0 );

    scene.add( camera );
    // create a wireframe material
    material = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      attributes: attributes,
      vertexShader: $('#vertexShader').text(),
      fragmentShader: $('#fragmentShader').text()
    });



    // create a sphere and assign the material
    mesh = new THREE.Mesh(
        new THREE.IcosahedronGeometry( 20, 4 ),
        material
    );

    var verts = mesh.geometry.vertices;Â 
    for (var v = 0; v < verts.length; v++) {
      attributes.displacement.value.push(_.random(0,30));
    }

    mesh.dynamic = true;

    var particleGeo = new THREE.Geometry();
    // creating geometry for particles
    for (i = 0; i < 20000; i++) {
      var particleVert = new THREE.Vector3();
      particleVert.x = _.random(-1000,1000);
      particleVert.y = _.random(-1000,1000);
      particleVert.z = _.random(-1000,1000)
      particleGeo.vertices.push(particleVert);
    }

    particleMat = new THREE.ParticleBasicMaterial({size:5});
    particles = new THREE.ParticleSystem(particleGeo, particleMat);
    scene.add(particles);

    // create the renderer and attach it to the DOM
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    container.appendChild( renderer.domElement );
    scene.add( mesh );
    render();

    var frame = 0;


    function render() {
      for(var index in particles.geometry.vertices) {
        var particle = particles.geometry.vertices[index];
        var x = particle.x;
        var y = particle.y;
        var z = particle.z;
        particle.x += x/100;
        particle.y += y/x/100;
        particle.y += z/x;
      }
      particles.geometry.verticesNeedUpdate = true;
      // particles.rotation.y += .001;
      // frame++;
      // mesh.rotation.x += _.random(-.1,.1);
      // mesh.rotation.y += _.random(-.1,.1);
      attributes.displacement.needsUpdate = true;
      var values = attributes.displacement.value;
      var TimeDomain = getTimeDomain();
      var frequency = getFrequencies();
      var red = frequency[5]/255;
      var green = frequency[7]/255;
      var blue = frequency[10]/255;
      particleMat.color = {r: 1, g: green, b: blue};
      uniforms.red.value = red;
      uniforms.green.value = green;
      uniforms.blue.value = blue;
      // Trying to find where pulse comes from
      // var maxFreq = [];
      // for (var index in TimeDomain) {
      //   frequency = TimeDomain[index];
      //   if (frequency = 255) maxFreq.push(index);
      // }
      // console.log(TimeDomain)
      // Update vertices to bucket
      for (var v = 0; v < verts.length; v++) {
        attributes.displacement.value[v] = TimeDomain[(v + frame) % TimeDomain.length];
      }
      // let there be light
      renderer.render( scene, camera );
      requestAnimationFrame( render );
      controls.update();
    }

    var timerId;

    $(document).ready(function() {
      $(".stop").on('click', function() {
        audio0.pause();
        audio0.currentTime = 0;
        // Stops the frequency data from being returned.
        clearInterval(timerId);
      });

      var samplerID = null;
      $(".play").on('click', function() {
        audio0.play();
        beginVisualiser();
        console.log('click');
      });

      $('body').on('click', function(){
        attributes.displacement['needsUpdate'] = true;
        console.log('clicked');
        attributes.displacement.value.push(_.random(0,30));
        console.log(attributes)
      })
    });
  } );

  </script>

</html>